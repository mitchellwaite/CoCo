	{ Semantic Operations }
	oMemoryLoadCode = 14;
	oMemoryFetchInstruction = 15;
	oMemoryFetchAddressOperand = 16;
	oMemoryFetchIntegerOperand = 17;
	oMemoryFetchBooleanOperand = 18;
	oMemoryFetchCharOperand = 19;
	oMemoryFetchChar = 20;
	oMemoryFetchInteger = 21;
	oMemoryFetchAddress = 22;
	oMemoryFetchBoolean = 23;
	oMemoryStoreChar = 24;
	oMemoryStoreInteger = 25;
	oMemoryStoreAddress = 26;
	oMemoryStoreBoolean = 27;
	oALUpop = 28;
	oALUpushTrap = 29; { (15) }
	oALUpushChar = 30;
	oALUpushInteger = 31;
	oALUpushAddress = 32;
	oALUpushBoolean = 33;
	oALUpopL = 34;
	oALUpopR = 35;
	oALUchooseR = 36; { >>13 }
	oALUpushLplusR = 37;
	oALUpushLminusR = 38;
	oALUpushLtimesR = 39;
	oALUpushLdivR = 40;
	oALUpushLmodR = 41;
	oALUpushLeqR = 42;
	oALUpushLneR = 43;
	oALUpushLgtR = 44;
	oALUpushLgeR = 45;
	oALUpushLltR = 46;
	oALUpushLleR = 47;
	oALUpushLandR = 48;
	oALUpushLorR = 49;
	oALUpushNotR = 50;
	oALUpushNegateR = 51;
	oALUpushChrR = 52;
	oALUpushOrdR = 53;
	oCUchooseInstruction = 54; { >>14 }
	oCUzeroPC = 55;
	oCUmoveMDRtoR = 56;
	oCUmoveMDRtoT = 57;
	oCUmoveMDRtoZ = 58;
	oCUmoveMDRtoIR = 59;
	oCUmoveMDRtoPC = 60;
	oCUmoveMDRtoSCR = 61;
	oCUmoveLtoMDR = 62;
	oCUmoveRtoMAR = 63;
	oCUmovePCtoMAR = 64;
	oCUmoveMARtoPC = 65;
	oCUincPC = 66;
	oCUpushPC = 67;
	oCUpopPC = 68;
	oCUcase = 69;
	oTrapHandlerTrap = 70; { >>13 }

	{ Input Tokens }

	{ Output Tokens }

	{ Input/Output Tokens }

	{ Error Codes }

	{ Type Values }
	{ Type 13 }
	bFALSE = 0;
	bTRUE = 1;
	{ Type 14 }
	tMultiply = 0;
	firstTcode = 0;
	tDivide = 1;
	tModulus = 2;
	tAdd = 3;
	tSubtract = 4;
	tEQ = 5;
	tNE = 6;
	tGT = 7;
	tGE = 8;
	tLT = 9;
	tLE = 10;
	tAnd = 11;
	tInfixAnd = 12;
	tOr = 13;
	tInfixOr = 14;
	tNegate = 15;
	tNot = 16;
	tChr = 17;
	tOrd = 18;
	tEoln = 19;
	tEOF = 20;
	tVarParm = 21;
	tFetchAddress = 22;
	tFetchInteger = 23;
	tFetchChar = 24;
	tFetchBoolean = 25;
	tAssignBegin = 26;
	tAssignAddress = 27;
	tAssignInteger = 28;
	tAssignChar = 29;
	tAssignBoolean = 30;
	tStoreParmAddress = 31;
	tStoreParmInteger = 32;
	tStoreParmChar = 33;
	tStoreParmBoolean = 34;
	tSubscriptBegin = 35;
	tSubscriptAddress = 36;
	tSubscriptInteger = 37;
	tSubscriptChar = 38;
	tSubscriptBoolean = 39;
	tArrayDescriptor = 40;
	tFileDescriptor = 41;
	tIfBegin = 42;
	tIfEnd = 43;
	tCaseBegin = 44;
	tWhileBegin = 45;
	tRepeatBegin = 46;
	tRepeatControl = 47;
	tCallBegin = 48;
	tParmEnd = 49;
	tProcedureEnd = 50;
	tWriteBegin = 51;
	tReadBegin = 52;
	tTrapBegin = 53;
	tWriteEnd = 54;
	tReadEnd = 55;
	tLiteralAddress = 56;
	firstCompoundTcode = 56;
	tLiteralInteger = 57;
	tLiteralChar = 58;
	tLiteralBoolean = 59;
	tLiteralString = 60;
	tStringDescriptor = 61;
	tSkipString = 62;
	tIfThen = 63;
	tIfMerge = 64;
	tCaseSelect = 65;
	tCaseMerge = 66;
	tCaseEnd = 67;
	tWhileTest = 68;
	tWhileEnd = 69;
	tRepeatTest = 70;
	tSkipProc = 71;
	tCallEnd = 72;
	tLineNumber = 73;
	tTrap = 74;
	lastCompoundTcode = 74;
	tEndOfFile = 75;
	lastTcode = 75;
	{ Type 15 }
	trHalt = 0;
	trReset = 1;
	trRewrite = 2;
	trRead = 3;
	trReadln = 4;
	trWrite = 5;
	trWriteln = 6;
	trWriteString = 7;
	trWriteInteger = 8;
	trWriteChar = 9;
	trReadInteger = 10;
	trReadChar = 11;
	trAssign = 12;
	trSubscriptAbort = 13;
	trCaseAbort = 14;
	trEoln = 15;
	trEof = 16;
	trFileDesc = 17;

	{ S/SL Rule Table Addresses } {
	PTmachine = 0;
	}

	{ S/SL Table Parameters }
	sslTblSize = 547;
	minSslTableValue = -32767;
	maxSslTableValue = 32767;
