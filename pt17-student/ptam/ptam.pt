{  PT Abstract Machine Version  Ver. 4.0

   Date: 4 August 2009 
         (Revised v4.0 - 19 Dec 2017)

   Author: J.R. Cordy, Queen's University

   Abstract:
    This is a new microprogrammed implementation of the PT Abstract Machine,
    as described in J. Alan Rosselet, "PT: A Pascal Subset", Tech Report CSRI-119,
    Computer Systems Research Institute, University of Toronto, Sept 1980.

   Input Files:
        input:       User input
        ptamSsl:     S/SL table generator from ptam.ssl
        tCode:       TCode instructions generated by the semantic analysis
                         pass for the source program.
        options:     Compiler options

   Output Files:
        output:      User output and diagnostic messages
}


program PTAM (input, output, ptamSsl, tCode, options);

    const

{ ===== Pasted contents of ptam.def, generated by S/SL from ptam.ssl -
        defines Semantic Operations, Input/Output Tokens, Error Codes and Semantic Types }

        { Semantic Operations }
        oMemoryLoadCode = 14;
        oMemoryFetchInstruction = 15;
        oMemoryFetchAddressOperand = 16;
        oMemoryFetchIntegerOperand = 17;
        oMemoryFetchBooleanOperand = 18;
        oMemoryFetchCharOperand = 19;
        oMemoryFetchChar = 20;
        oMemoryFetchInteger = 21;
        oMemoryFetchAddress = 22;
        oMemoryFetchBoolean = 23;
        oMemoryStoreChar = 24;
        oMemoryStoreInteger = 25;
        oMemoryStoreAddress = 26;
        oMemoryStoreBoolean = 27;
        oALUpop = 28;
        oALUpushTrap = 29; { (15) }
        oALUpushChar = 30;
        oALUpushInteger = 31;
        oALUpushAddress = 32;
        oALUpushBoolean = 33;
        oALUpopL = 34;
        oALUpopR = 35;
        oALUchooseR = 36; { >>13 }
        oALUpushLplusR = 37;
        oALUpushLminusR = 38;
        oALUpushLtimesR = 39;
        oALUpushLdivR = 40;
        oALUpushLmodR = 41;
        oALUpushLeqR = 42;
        oALUpushLneR = 43;
        oALUpushLgtR = 44;
        oALUpushLgeR = 45;
        oALUpushLltR = 46;
        oALUpushLleR = 47;
        oALUpushLandR = 48;
        oALUpushLorR = 49;
        oALUpushNotR = 50;
        oALUpushNegateR = 51;
        oALUpushChrR = 52;
        oALUpushOrdR = 53;
        oCUchooseInstruction = 54; { >>14 }
        oCUzeroPC = 55;
        oCUmoveMDRtoR = 56;
        oCUmoveMDRtoT = 57;
        oCUmoveMDRtoZ = 58;
        oCUmoveMDRtoIR = 59;
        oCUmoveMDRtoPC = 60;
        oCUmoveMDRtoSCR = 61;
        oCUmoveLtoMDR = 62;
        oCUmoveRtoMAR = 63;
        oCUmovePCtoMAR = 64;
        oCUmoveMARtoPC = 65;
        oCUincPC = 66;
        oCUpushPC = 67;
        oCUpopPC = 68;
        oCUcase = 69;
        oTrapHandlerTrap = 70; { >>13 }

        { Input Tokens }

        { Output Tokens }

        { Input/Output Tokens }

        { Error Codes }

        { Type Values }
        { Type 13 }
        bFALSE = 0;
        bTRUE = 1;
        { Type 14 }
        tMultiply = 0;
        firstTcode = 0;
        tDivide = 1;
        tModulus = 2;
        tAdd = 3;
        tSubtract = 4;
        tEQ = 5;
        tNE = 6;
        tGT = 7;
        tGE = 8;
        tLT = 9;
        tLE = 10;
        tAnd = 11;
        tInfixAnd = 12;
        tOr = 13;
        tInfixOr = 14;
        tNegate = 15;
        tNot = 16;
        tChr = 17;
        tOrd = 18;
        tEoln = 19;
        tEOF = 20;
        tVarParm = 21;
        tFetchAddress = 22;
        tFetchInteger = 23;
        tFetchChar = 24;
        tFetchBoolean = 25;
        tAssignBegin = 26;
        tAssignAddress = 27;
        tAssignInteger = 28;
        tAssignChar = 29;
        tAssignBoolean = 30;
        tStoreParmAddress = 31;
        tStoreParmInteger = 32;
        tStoreParmChar = 33;
        tStoreParmBoolean = 34;
        tSubscriptBegin = 35;
        tSubscriptAddress = 36;
        tSubscriptInteger = 37;
        tSubscriptChar = 38;
        tSubscriptBoolean = 39;
        tArrayDescriptor = 40;
        tFileDescriptor = 41;
        tIfBegin = 42;
        tIfEnd = 43;
        tCaseBegin = 44;
        tWhileBegin = 45;
        tRepeatBegin = 46;
        tRepeatControl = 47;
        tCallBegin = 48;
        tParmEnd = 49;
        tProcedureEnd = 50;
        tWriteBegin = 51;
        tReadBegin = 52;
        tTrapBegin = 53;
        tWriteEnd = 54;
        tReadEnd = 55;
        tLiteralAddress = 56;
        firstCompoundTcode = 56;
        tLiteralInteger = 57;
        tLiteralChar = 58;
        tLiteralBoolean = 59;
        tLiteralString = 60;
        tStringDescriptor = 61;
        tSkipString = 62;
        tIfThen = 63;
        tIfMerge = 64;
        tCaseSelect = 65;
        tCaseMerge = 66;
        tCaseEnd = 67;
        tWhileTest = 68;
        tWhileEnd = 69;
        tRepeatTest = 70;
        tSkipProc = 71;
        tCallEnd = 72;
        tLineNumber = 73;
        tTrap = 74;
        lastCompoundTcode = 74;
        tEndOfFile = 75;
        lastTcode = 75;
        { Type 15 }
        trHalt = 0;
        trReset = 1;
        trRewrite = 2;
        trRead = 3;
        trReadln = 4;
        trWrite = 5;
        trWriteln = 6;
        trWriteString = 7;
        trWriteInteger = 8;
        trWriteChar = 9;
        trReadInteger = 10;
        trReadChar = 11;
        trAssign = 12;
        trSubscriptAbort = 13;
        trCaseAbort = 14;
        trEoln = 15;
        trEof = 16;
        trFileDesc = 17;

        { S/SL Rule Table Addresses } {
        PTmachine = 0;
        }

        { S/SL Table Parameters }
        sslTblSize = 547;
        minSslTableValue = -32767;
        maxSslTableValue = 32767;

{ ===== End of contents of ptam.def }

        { Input tokens - none for this program, so these are just placeholders. }
        firstInputToken = 0;
        firstCompoundToken = 1;
        lastCompoundToken = 0;
        lastInputToken = 0;

        { S/SL table operations }
        firstTableOperation = 0;
        lastTableOperation = 120;

        { Primitive operations }
        oCall = 0;
        oReturn = 1;
        oRuleEnd = 2;
        oJumpBack = 3;
        oJumpForward = 4;
        oInput = 5;
        oInputAny = 6;
        oInputChoice = 7;
        oEmit = 8;
        oError = 9;
        oChoice = 10;
        oChoiceEnd = 11;
        oSetParameter = 12;
        oSetResult = 13;

        { Error Codes }
        firstErrorCode = 10;
        firstFatalError = 21;
        eSubscriptError = 21;
        eCaseError = 22;
        eSslStackOvfl = 24;
        lastErrorCode = 24;

        { S/SL System Failure Codes }
        firstFailureCode = 0;
        fSemanticChoiceFailed = 0;
        fChoiceRuleFailed = 1;
        lastFailureCode = 1;

        { PT Abstract Machine Limits }
        sslTableSize = 5000;
        maxInteger = 32767;
        minInteger = -32767;
        sslStackSize = 100;
        codeMemorySize = 50000;
        dataMemorySize = 500000;
        expnStackSize = 80;
        returnStackSize = 250;
        maxLineNumber = 9999;

        { Machine word size }
        wordSize = 4;           

        { Misc }
        undefined = minInteger;

        { Assertion identification values }
        assert1 = 1;
        assert2 = 2;
        assert3 = 3;
        assert4 = 4;
        assert5 = 5;
        assert6 = 6;
        assert7 = 7;
        assert8 = 8;
        assert9 = 9;
        assert10 = 10;
        assert11 = 11;
        assert12 = 12;
        assert13 = 13;
        assert14 = 14;
        assert15 = 15;
        assert16 = 16;
        assert17 = 17;
        assert18 = 18;
        assert19 = 19;
        assert20 = 20;
        assert21 = 21;
        assert22 = 22;
        assert23 = 23;
        assert24 = 24;
        assert25 = 25;
        assert26 = 26;
        assert27 = 27;
        assert28 = 28;
        assert29 = 29;
        assert30 = 30;
        assert31 = 31;
        assert32 = 32;
        assert33 = 33;
        assert34 = 34;

    type
        InputTokens = firstInputToken .. lastInputToken;
        ErrorCodes = firstErrorCode .. lastErrorCode;
        FailureCodes = firstFailureCode .. lastFailureCode;

    var 
        { The Syntax/Semantic Table;
          The S/SL table file produced by the S/SL Processor 
          for the pass is read into this array during initialization. }
        sslTable: array [0 .. sslTableSize] of integer;
        ptamSsl:  file of integer;

        { Table Walker State }
        processing: Boolean             { initially true };
        sslPointer: 0 .. sslTableSize   { initially 0 };
        operation: firstTableOperation .. lastTableOperation;

        { Tracing Control }
        options: text;
        tracing: Boolean        { initially false };

        { Abort flag }
        sslabort: Boolean       { initially false };

        { The S/SL Rule Call Stack:
          The Rule Call Stack implements Syntax/Semantic Language rule call and return.
          Each time an oCall operation is executed, the table return address is pushed onto the
          Rule Call Stack.  When an oReturn is executed, the return address is popped from 
          the stack.  An oReturn executed when the Rule Call Stack is empty terminates table 
          execution. }
        sslStack:    array [1 .. sslStackSize] of 0 .. sslTableSize;
        sslStackTop: 0 .. sslStackSize  { initially 0 };

        { Choice Match Flag:
          Set by the Choice Handler to indicate whether a match was made or the otherwise path 
          was taken.  Set to true if a match was made and false otherwise.
          This flag is used in input choices to indicate whether the choice input token 
          should be accepted or not. }
        choiceTagMatched: Boolean;

        { Parameterized And Choice Semantic Operation Values:
          These are used to hold the decoded parameter value to a parameterized semantic operation 
          and the result value returned by a choice semantic operation or rule respectively. }
        parameterValue: integer;
        resultValue:    integer;

        { Line Counters }
        nextLineNumber: 0 .. maxLineNumber      { initially 0 };
        lineNumber: 0 .. maxLineNumber;
        lastEmittedLineNumber:  integer;

        { Error Counter }
        noErrors: integer  { initially 0 };

        { Input Interface }
        nextInputToken: InputTokens;
        tCode: file of integer;

        { Output Interface }

        { Global temporaries }
        i: integer;

        { Memory Mechanism }
        codeMemory: array [0 .. codeMemorySize] of integer;
        dataMemory: array [0 .. dataMemorySize] of integer;
        dataAreaSize: integer;
        MAR: integer;
        MDR: integer;

        { Expression Stack }
        expnStack: array [0 .. expnStackSize] of integer;
        expnSP:    integer;

        { Return Stack }
        returnStack: array [0 .. returnStackSize] of integer;
        returnSP:    integer;

        { ALU }
        L: integer;
        R: integer;
        Z: integer;

        { CU }
        IR:  integer;
        PC:  integer;
        T:   integer;
        SCR: integer;

        { Trap Handler - User I/O Files }

        { UNIX argument file names }
        {NptamSsl, NtCode, Noptions:
                packed array [1 .. 50] of char;}


    procedure Assert (assertion: Boolean; number: integer);
        { Procedure to implement programmer assertion checking with identification numbers. }
        begin
            if not assertion then
                begin
                    write ('### PTAM Assertion ', number: 1, ' failed: ');

                    case number of
                        assert1, assert2, assert3, assert4, assert5, assert6:
                            ; { Unused }
                        assert7, assert9:
                            write ('internal error in ptam.pt (report to maintainer)');
                        assert8:
                            ; { Problem message already reported }
                        assert10, assert11, assert12, assert13, assert14, assert15, 
                        assert16, assert17, assert18, assert19, assert20, assert21, assert22:
                            ; { Unused }
                        assert23:
                            write ('sslTableSize too small (increase in ptam.pt)');
                        assert24:
                            ; { Unused }
                        assert25:
                            write ('ptam phase ended without consuming all of tCode token stream');
                        assert26:
                            write ('expression stack not empty at end of ptam phase');
                        assert27:
                            write ('return stack not empty at end of ptam phase');
                        assert28, assert29, assert30:
                            ; { Unused }
                        assert31:
                            write ('empty expression stack in oALUpop');
                        assert32:
                            write ('expression stack overflow in oALUpush');
                        assert33:
                            write ('empty return stack in oCUreturnPop');
                        assert34:
                            write ('return stack overflow in oCUreturnPush');
                    end;
                    writeln;
                    processing := false;
                    sslabort := true;
                end;
        end { Assert };

    procedure SubscriptError (subscript: integer;
                             lowerBound: integer;
                             upperBound: integer);
        { Report a manifest subscript out of bounds. }
        begin
            write ('line ', lineNumber: 1, ': subscript [', subscript: 1, '] out of bounds [', 
                lowerBound: 1, ' .. ', upperBound: 1, ']');
            writeln;
            noErrors := noErrors + 1;
        end { SubscriptError };

    procedure Error (errorCode: ErrorCodes);
        { Report an error and abort processing if the error was fatal. }
        begin
            write ('execution error, line ', lineNumber:1, ': ');
            if errorCode > firstFatalError then
                write ('program too complicated ');
            case errorCode of
                eSubscriptError: write ('subscript out of range');
                eCaseError: write ('case expression out of range');
                eSslStackOvfl: write (' (SSL stack)');
            end;
            writeln;
            noErrors := noErrors + 1;
            if errorCode >= firstFatalError then
                begin
                    processing := false;  { terminate coding }
                    sslabort := true;
                end;
        end { Error };

    procedure Initialize;                               
        { Set the compiler options from the options file, read in the S/SL table corresponding 
          to coder.ssl, initialize the coder semantic mechanisms. }

        var
            i: integer;
            c: char;

        begin
            { Get UNIX argument file names }
            
            {argv (1, NptamSsl);}
            {argv (2, NtCode);}
            {argv (3, Noptions);}
            

            { Trace Execution if Required }
            tracing := false;
            reset (options {, Noptions} );

            while not eof (options) do
                begin
                    read (options, c);
                    if c = 't' then
                        begin
                            read (options, c);
                            if (c = '4') then
                                tracing := true
                        end;
                end;

            { Initialize the coder ssl table }
            reset (ptamSsl {, NptamSsl} );
            i := 0;
            while not eof (ptamSsl) do
                begin
                    if i > sslTableSize then
                        Assert (false, assert23);
                    read (ptamSsl, sslTable[i]);
                    i := i + 1
                end;

            { Initialize Input/Output }
            reset (tCode {, NtCode} );

            { Initialize semantic mechanisms }
            PC := 0;
            SCR := 0;
            expnSP := 0;
            returnSP := 0;

            { Discard the error count word, the ptc command file has already
              checked it and aborted compilation if semantic errors were found.}
            read (tCode, i);

            read (tCode, dataAreaSize);
            { Round the data area size up to a word (VAX 4 byte) boundary }
            dataAreaSize := dataAreaSize + dataAreaSize mod wordSize;

            read (tCode, i);    { tCode size }

        end { Initialize };


    { Procedures to implement the PTAM semantic mechanisms. }

    procedure ALUpush (value: integer);
        begin
            Assert (expnSP < expnStackSize, assert32);
            expnSP := expnSP + 1;
            expnStack[expnSP] := value;
        end;

    procedure ALUpop (var result: integer);
        begin
            Assert (expnSP > 0, assert31);
            result := expnStack[expnSP];
            expnSP := expnSP - 1;
        end;

    procedure CUreturnPush (value: integer);
        begin
            Assert (returnSP < returnStackSize, assert34);
            returnSP := returnSP + 1;
            returnStack[returnSP] := value;
        end;

    procedure CUreturnPop (var result: integer);
        begin
            Assert (returnSP > 0, assert33);
            result := returnStack[returnSP];
            returnSP := returnSP - 1;
        end;

    procedure CUcase;
        var lowerBound : integer;
            upperBound : integer;
        begin
            lowerBound := codeMemory[R];
            upperBound := codeMemory[R+1];
            if (L >= lowerBound) and (L <= upperBound) then
                PC := codeMemory[R + 2 + L - Z];
            { otherwise we fall through to case abort }
        end;

    procedure MemoryLoadCode;
        var
            tAddress: integer;
        begin
            tAddress := 0;
            while (not eof (tCode)) do
            begin
                read (tCode, codeMemory[tAddress]);
                tAddress := tAddress + 1;
            end;
        end;

    procedure TrapHandlerTrap (trap: integer);

        var
            fdaddress:  integer;
            fdtextfile: text;
            fdbinfile:  file of integer;
            fdfilename: packed array [1 .. 256] of char;
            fdnumber: integer;
            length:   integer;
            address:  integer;
            value:    integer;
            charvalue: char;
            j: integer;

        begin
            case trap of

                trHalt:
                    ;

                trReset: 
                    begin
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        reset (fdtextfile);
                    end;
                    
                trRewrite: 
                    begin
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        rewrite (fdtextfile);
                    end;

                trWrite: 
                    begin
                        ALUpop (length);
                        ALUpop (value);
                        ALUpop (fdaddress);
                        fdbinfile := file (dataMemory[fdaddress]);
                        write (fdbinfile, value);
                    end;

                trWriteln:
                    begin
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        writeln (fdtextfile);
                    end;

                trWriteString: 
                    begin
                        ALUpop (length);
                        ALUpop (address);
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);

                        if length < 0 then 
                            begin
                                { string literal }
                                length := -length;
                                j := 0;
                                while (j < length) and (codeMemory[address + j] <> 0) do
                                    begin
                                        write (fdtextfile, chr (codeMemory[address + j]));
                                        j := j + 1;
                                    end;
                            end
                        else
                            begin
                                { char array }
                                j := 0;
                                while (j < 255) and (dataMemory[address + j] <> 0) do
                                    begin
                                        write (fdtextfile, chr (dataMemory[address + j]));
                                        j := j + 1;
                                    end;
                            end;
                    end;

                trWriteInteger: 
                    begin
                        ALUpop (length);
                        ALUpop (value);
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        write (fdtextfile, value : length);
                    end;

                trWriteChar: 
                    begin
                        ALUpop (length);
                        ALUpop (value);
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        write (fdtextfile, chr (value) : length);
                    end;

                trRead: 
                    begin
                        ALUpop (length);
                        ALUpop (address);
                        ALUpop (fdaddress);
                        fdbinfile := file (dataMemory[fdaddress]);
                        read (fdbinfile, dataMemory[address]);
                    end;

                trReadln: 
                    begin
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        readln (fdtextfile);
                    end;

                trReadInteger: 
                    begin
                        ALUpop (address);
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        read (fdtextfile, dataMemory[address]);
                    end;

                trReadChar:
                    begin
                        ALUpop (address);
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        read (fdtextfile, charvalue);
                        dataMemory[address] := ord (charvalue);
                    end;

                trAssign:
                    begin
                        ALUpop (length);
                        ALUpop (address);
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);

                        if length < 0 then 
                            begin
                                { string literal }
                                length := -length;
                                j := 0;
                                while (j < length) and (codeMemory[address + j] <> 0) do
                                    begin
                                        fdfilename[j+1] := chr (codeMemory[address + j]);
                                        j := j + 1;
                                    end;
                                fdfilename[j+1] := chr (0);
                            end
                        else
                            begin
                                { char array }
                                j := 0;
                                while (j < 255) and (dataMemory[address + j] <> 0) do
                                    begin
                                        fdfilename[j+1] := chr (dataMemory[address + j]);
                                        j := j + 1;
                                    end;
                                fdfilename[j+1] := chr (0);
                            end;

                        fdfilename[j+1] := chr (0);
                        assign (fdtextfile, fdfilename);
                        dataMemory[fdaddress] := file (fdtextfile);
                    end;

                trSubscriptAbort:
                    Error (eSubscriptError);

                trCaseAbort:
                    Error (eCaseError);

                trEoln:
                    begin
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        if eoln (fdtextfile) then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);
                    end;

                trEof:
                    begin
                        ALUpop (fdaddress);
                        fdtextfile := file (dataMemory[fdaddress]);
                        if eof (fdtextfile) then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);
                    end;

                trFileDesc:
                    begin
                        ALUpop (fdaddress);
                        ALUpop (fdnumber);
                        if fdnumber > 2 then
                            fdnumber := fdnumber + 3;
                        ALUpush (fdnumber);
                        ALUpush (fdaddress);
                    end;

            end {case trap};
        end;

    procedure AcceptInputToken;
        { This procedure provides the interface to the previous pass;  
          it is reponsible for handling all input including line number indicators and
          the values and text associated with input tokens. }
        begin
        end { AcceptInputToken };

    procedure SslSyntaxError;
        { A syntax error can only be the result of an error in the previous pass. }
        begin
            Assert (false, assert7);
        end { SslSyntaxError };

    procedure SslTrace;
        begin
            write ('Table index ', sslPointer-1: 1, ';  Operation ', 
                operation: 1, ';  Argument ', sslTable[sslPointer]: 1);
            writeln;
        end { SslTrace };

    procedure SslFailure (failCode: FailureCodes);
        begin
            write ('### S/SL program failure: ');

            case failCode of
                fSemanticChoiceFailed:
                    write ('Semantic choice failed');
                fChoiceRuleFailed:
                    write ('Choice rule returned without a value');
            end;

            writeln;
            write ('while processing line ', lineNumber);
            writeln;
            SslTrace;
            Assert (false, assert8);
        end { SslFailure };

    procedure SslChoice (choiceTag: integer);

        { This procedure performs both input and semantic choices.  It sequentially tests 
          each alternative value against the tag value, and when a match is found, 
          performs a branch to the corresponding alternative path.  If none of the alternative
          values matches the tag value, sslTable interpretation proceeds to the operation 
          immediately following the list of alternatives (normally the otherwise path).  
          The flag choiceTagMatched is set to true if a match is found and false otherwise. }

        var
            numberOfChoices: integer;

        begin
            sslPointer := sslPointer + sslTable[sslPointer];
            numberOfChoices := sslTable[sslPointer];
            sslPointer := sslPointer + 1;
            choiceTagMatched := false;

            repeat
                if sslTable[sslPointer] = choiceTag then
                    begin
                        sslPointer := sslPointer + 1;
                        sslPointer := sslPointer - sslTable[sslPointer];
                        choiceTagMatched := true;
                        numberOfChoices := 0;
                    end
                  else
                    begin
                        sslPointer := sslPointer + 2;
                        numberOfChoices := numberOfChoices - 1;
                    end;

            until numberOfChoices = 0;

            if tracing then
                begin
                    write ('Choice tag ', choiceTag : 1);
                    if choiceTagMatched then
                        write (' (matched)')
                    else
                        write (' (not matched)');
                    writeln
                end

        end { SslChoice };


    procedure Interpret;
        { Walk the ssl code generator table. }

        begin
            { Initialize Table Walker State }
            processing := true;
            sslPointer := 0;
            sslStackTop := 0;
            noErrors := 0;
            sslabort := false;
            AcceptInputToken;

            repeat { until processing = false }

                operation := sslTable[sslPointer];
                sslPointer := sslPointer + 1;

                if tracing then
                    SslTrace;

                case operation of

                    oCall:
                        if sslStackTop < sslStackSize then
                            { no allowance for long calls }
                            begin
                                sslStackTop := sslStackTop + 1;
                                sslStack[sslStackTop] := sslPointer + 1;
                                sslPointer := sslTable[sslPointer]
                            end
                          else
                            begin
                                Error (eSslStackOvfl);
                                processing := false
                            end;

                    oReturn:
                        if sslStackTop > 0 then
                            begin
                                sslPointer := sslStack[sslStackTop];
                                sslStackTop := sslStackTop - 1
                            end
                          else
                            processing := false;        { normal return }

                    oRuleEnd:
                        SslFailure (fChoiceRuleFailed);

                    oJumpForward:
                        sslPointer := sslPointer + sslTable[sslPointer];

                    oJumpBack:
                        sslPointer := sslPointer - sslTable[sslPointer];

                    oInput:
                        begin
                            if nextInputToken = sslTable[sslPointer] then
                                AcceptInputToken
                              else
                                SslSyntaxError;
                            sslPointer := sslPointer + 1
                        end;

                    oInputAny:
                        if nextInputToken <> tEndOfFile then
                            AcceptInputToken
                        else
                            { Premature end of file }
                            SslSyntaxError;

                    oInputChoice:
                        begin
                            SslChoice (nextInputToken);
                            if choiceTagMatched then
                                AcceptInputToken
                        end;

                    oEmit:
                        { No emitting operations }
                        Assert (false, assert9);

                    oError:
                        begin
                            Error (sslTable[sslPointer]);
                            sslPointer := sslPointer + 1
                        end;

                    oChoice:
                        SslChoice (resultValue);

                    oChoiceEnd:
                        SslFailure (fSemanticChoiceFailed);

                    oSetParameter:
                        begin
                            parameterValue := sslTable[sslPointer];
                            sslPointer := sslPointer + 1
                        end;

                    oSetResult:
                        begin
                            resultValue := sslTable[sslPointer];
                            sslPointer := sslPointer + 1
                        end;


                    { ****
                      *  *  Memory Mechanism Operations
                      **** }

                    oMemoryLoadCode:
                        MemoryLoadCode;

                    oMemoryFetchInstruction:
                        MDR := codeMemory[MAR];

                    oMemoryFetchAddressOperand,
                    oMemoryFetchIntegerOperand,
                    oMemoryFetchBooleanOperand,
                    oMemoryFetchCharOperand:
                        MDR := codeMemory[MAR];

                    oMemoryFetchChar,
                    oMemoryFetchInteger,
                    oMemoryFetchAddress,
                    oMemoryFetchBoolean:
                        MDR := dataMemory[MAR];

                    oMemoryStoreChar,
                    oMemoryStoreInteger,
                    oMemoryStoreAddress,
                    oMemoryStoreBoolean:
                        dataMemory[MAR] := MDR;


                    { ****
                      *  *  ALU Mechanism Operations
                      **** }

                    oALUpop:
                        ALUpop (i);

                    oALUpushTrap:
                        ALUpush (parameterValue);

                    oALUpushChar,
                    oALUpushInteger,
                    oALUpushAddress,
                    oALUpushBoolean:
                        ALUpush (R);
                        
                    oALUpopL:
                        ALUpop (L);

                    oALUpopR:
                        ALUpop (R);

                    oALUchooseR:
                        resultValue := R;

                    oALUpushLplusR:
                        ALUpush (L + R);

                    oALUpushLminusR:
                        ALUpush (L - R);

                    oALUpushLtimesR:
                        ALUpush (L * R);

                    oALUpushLdivR:
                        ALUpush (L div R);

                    oALUpushLmodR:
                        ALUpush (L mod R);

                    oALUpushLeqR:
                        if L = R then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);
                            
                    oALUpushLneR:
                        if L <> R then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);
                            
                    oALUpushLgtR:
                        if L > R then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);
                            
                    oALUpushLgeR:
                        if L >= R then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);
                            
                    oALUpushLltR:
                        if L < R then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);
                            
                    oALUpushLleR:
                        if L <= R then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);
                            
                    oALUpushLandR:
                        if (L = bTRUE) and (R = bTRUE) then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);

                    oALUpushLorR:
                        if (L = bTRUE) or (R = bTRUE) then
                            ALUpush (bTRUE)
                        else
                            ALUpush (bFALSE);

                    oALUpushNotR:
                        if R = bTRUE then
                            ALUpush (bFALSE)
                        else
                            ALUpush (bTRUE);

                    oALUpushNegateR:
                        ALUpush (-R);

                    oALUpushChrR:
                        ALUpush (ord (chr (R)));

                    oALUpushOrdR:
                        ALUpush (ord (chr (R)));


                    { ****
                      *  *  CU Mechanism Operations
                      **** }

                    oCUchooseInstruction:
                        resultValue := IR;

                    oCUzeroPC:
                        PC := 0;

                    oCUmoveMDRtoR:
                        R := MDR;

                    oCUmoveMDRtoT:
                        T := MDR;

                    oCUmoveMDRtoZ:
                        Z := MDR;

                    oCUmoveMDRtoIR:
                        IR := MDR;

                    oCUmoveMDRtoPC:
                        { Fix bug in tCode }
                        if MDR = 0 then
                            PC := PC + 1
                        else
                            PC := MDR;

                    oCUmoveMDRtoSCR:
                        SCR := MDR;

                    oCUmoveLtoMDR:
                        MDR := L;

                    oCUmoveRtoMAR:
                        MAR := R;

                    oCUmovePCtoMAR:
                        MAR := PC;

                    oCUmoveMARtoPC:
                        PC := MAR;

                    oCUincPC:
                        PC := PC + 1;

                    oCUpushPC:
                        CUreturnPush (PC);

                    oCUpopPC:
                        CUreturnPop (PC);

                    oCUcase:
                        CUcase;

                    { ****
                      *  *  Trap Handler Mechanism Operations
                      **** }

                    oTrapHandlerTrap:
                        begin
                            TrapHandlerTrap (T);

                            if T = trHalt then
                                resultValue := bTRUE
                            else
                                resultValue := bFALSE;
                        end;

                end { case operation };

            until not processing;

            if not sslabort then
                Assert (eof (tCode), assert25);

        end; { Interpret }


    procedure Finalize;
        begin
            { If the table walker terminated normally check that the state
              of the semantic mechanisms is legal.                       }
            if not sslabort then
                { If everything happened legitimately, the stacks should be empty }
                begin
                    Assert (expnSP = 0, assert26);
                    Assert (returnSP = 0, assert27);
                end;

        end { Finalize };

    begin
        { N.B. We assume here that the invoker of the PTAM (e.g. the ptc command) 
          has insured that the token stream emitted by the semantic pass is valid 
          (i.e. no semantic errors detected).  If the stream is illegal the first word 
          will be a positive integer value. }

        Initialize;
        Interpret;
        Finalize;
    end.
